(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{451:function(t,a,s){"use strict";s.r(a);var r=s(34),v=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"数组"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数组"}},[t._v("#")]),t._v(" 数组")]),t._v(" "),s("p",[t._v("数组（Array），是有限个相同类型的变量所组成的有序集合，数组中的每一个变量被称为元素。")]),t._v(" "),s("h4",{attrs:{id:"特点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#特点"}},[t._v("#")]),t._v(" 特点")]),t._v(" "),s("ul",[s("li",[t._v("数组中的每一个元素也有着自己的“下标”，下标从0开始")]),t._v(" "),s("li",[t._v("数组在内存当中"),s("strong",[t._v("顺序存储")]),t._v("，，可以很好地实现逻辑上的“顺序表”")])]),t._v(" "),s("blockquote",[s("p",[t._v("什么叫做顺序存储呢？"),s("br"),t._v("\n内存是由一个个连续的内存单元所组成的，每一个内存单元都有着自己的地址。在这些内存单元中，有些被其他数据占用了，有些是空闲的。"),s("br"),t._v("\n数组中的每一个元素，都存储在小小的内存单元当中，并且元素之间紧密排列，既不能打乱存储顺序，也不能“跳过”存储单元。"),s("br"),t._v(" "),s("img",{staticStyle:{width:"30%"},attrs:{src:t.$withBase("/img/algorithm/7.jpg")}}),s("br"),t._v("\n上面图中，蓝色的格子代表着空闲的存储单元，紫色的格子代表已占用的存储单元，而绿色的连续格子，代表着数组在内存中的位置。")])]),t._v(" "),s("h2",{attrs:{id:"操作"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#操作"}},[t._v("#")]),t._v(" 操作")]),t._v(" "),s("h3",{attrs:{id:"查找"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#查找"}},[t._v("#")]),t._v(" 查找")]),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" array "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("array"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 1")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br")])]),s("p",[t._v("通过下标直接读取"),s("code",[t._v("array[0]")]),t._v(" ,"),s("strong",[t._v("时间复杂度为O(1)。")])]),t._v(" "),s("h3",{attrs:{id:"更新"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#更新"}},[t._v("#")]),t._v(" 更新")]),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" array "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n\narray"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("array"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// [0, 2, 3, 4]")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br")])]),s("p",[t._v("更新直接利用数组下标，就可以把新的值赋给该元素，"),s("strong",[t._v("时间复杂度为O(1)。")])]),t._v(" "),s("h3",{attrs:{id:"插入"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#插入"}},[t._v("#")]),t._v(" 插入")]),t._v(" "),s("p",[t._v("插入时，数组的实际元素数量有可能小于数组的长度，比如下面的情形："),s("br"),t._v(" "),s("img",{staticStyle:{width:"30%"},attrs:{src:t.$withBase("/img/algorithm/8.jpg")}}),s("br"),t._v("\n由此，数组插入元素的操作分成了三种情况：尾部插入、中间插入、以及超范围插入。")]),t._v(" "),s("ul",[s("li",[t._v("尾部插入，是最简单的情况，直接把插入的元素放在数组尾部的空闲位置即可，等同于更新元素操作。")]),t._v(" "),s("li",[t._v("中间插入，首先把插入位置以及后面的元素向后错开，腾出地方，再把要插入的元素放到对应的数组位置上。")]),t._v(" "),s("li",[t._v("超范围插入，需要对数组进行扩容，再把旧数组的元素通通复制过去")])]),t._v(" "),s("p",[t._v("插入时，后面的每个元素都要跟着移动位置，因此"),s("strong",[t._v("时间复杂度为O(n)。")])]),t._v(" "),s("h3",{attrs:{id:"删除"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#删除"}},[t._v("#")]),t._v(" 删除")]),t._v(" "),s("p",[t._v("数组的删除操作和插入操作是相反的过程，如果删除的元素位于数组中间，其后的元素都需要向前挪一位。"),s("strong",[t._v("时间复杂度为O(n)。")])]),t._v(" "),s("h2",{attrs:{id:"时间复杂度"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#时间复杂度"}},[t._v("#")]),t._v(" 时间复杂度")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("操作")]),t._v(" "),s("th",[t._v("复杂度")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("查询")]),t._v(" "),s("td",[t._v("O(1)")])]),t._v(" "),s("tr",[s("td",[t._v("修改")]),t._v(" "),s("td",[t._v("O(1)")])]),t._v(" "),s("tr",[s("td",[t._v("插入")]),t._v(" "),s("td",[t._v("O(n)")])]),t._v(" "),s("tr",[s("td",[t._v("删除")]),t._v(" "),s("td",[t._v("O(n)")])])])]),t._v(" "),s("h2",{attrs:{id:"链表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#链表"}},[t._v("#")]),t._v(" 链表")]),t._v(" "),s("p",[t._v("链表（Linked List），它是一种在物理上非连续、非顺序的数据结构，由若干个节点（node）所组成。")]),t._v(" "),s("p",[s("strong",[t._v("节点是链表的基本单元")])]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("单向链表")]),t._v("的每一个节点都包含两个部分，一部分是存放数据的变量data，一部分是指向下一个节点的指针next，终点指向null。")]),t._v(" "),s("li",[s("strong",[t._v("双向链表")]),t._v("比单向链表稍微复杂一些，每一个节点除了拥有data和next指针，还拥有指向前置节点的prev指针。")])]),t._v(" "),s("h3",{attrs:{id:"存储方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#存储方式"}},[t._v("#")]),t._v(" 存储方式")]),t._v(" "),s("p",[t._v("数组在内存中占用了连续完整的存储空间。")]),t._v(" "),s("p",[t._v("而链表则是采用了“见缝插针”的方式，每一个节点分布在内存的不同位置，依靠next指针关联起来。这样可以灵活有效地利用零散的碎片空间。")]),t._v(" "),s("h2",{attrs:{id:"操作-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#操作-2"}},[t._v("#")]),t._v(" 操作")]),t._v(" "),s("h3",{attrs:{id:"查找-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#查找-2"}},[t._v("#")]),t._v(" 查找")]),t._v(" "),s("p",[t._v("在查找元素时，链表不像数组那样可以通过下标快速定位元素，只能是从头节点向后，一个个节点逐一来查找。")]),t._v(" "),s("p",[t._v("比如给定一个链表，我们要查找从头节点开始的第3个节点：")]),t._v(" "),s("ol",[s("li",[t._v("第1步，查找的指针定位到头节点")]),t._v(" "),s("li",[t._v("第2步，根据头节点的next指针，定位到第2个节点")]),t._v(" "),s("li",[t._v("第3步，根据第2个节点的next指针，定位到第3个节点，查找完毕")])]),t._v(" "),s("p",[t._v("链表中的数据只能够按顺序进行访问，最坏时间复杂度是O（n）。")]),t._v(" "),s("h3",{attrs:{id:"更新-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#更新-2"}},[t._v("#")]),t._v(" 更新")]),t._v(" "),s("p",[t._v("如果不考虑查找节点的过程，数组和链表的更新过程都同样简单，直接把旧数据替换成新数据即可，"),s("strong",[t._v("时间复杂度为O(1)。")])]),t._v(" "),s("h3",{attrs:{id:"插入-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#插入-2"}},[t._v("#")]),t._v(" 插入")]),t._v(" "),s("p",[t._v("和数组类似，链表插入节点时，同样分为三种情况：")]),t._v(" "),s("ul",[s("li",[t._v("尾部插入，是最简单的情况，把最后一个节点的next指针指向新插入的节点即可")]),t._v(" "),s("li",[t._v("头部插入，可以分成两个步骤：\n"),s("ol",[s("li",[t._v("把新节点的next指针指向原先的头节点")]),t._v(" "),s("li",[t._v("把前置节点的next指针，指向刚刚插入的新节点。")])])]),t._v(" "),s("li",[t._v("中间插入，同样分为两个步骤：\n"),s("ol",[s("li",[t._v("把新节点的next指针，指向前置节点next所指向的位置。")]),t._v(" "),s("li",[t._v("把前置节点的next指针，指向刚刚插入的新节点。")])])])]),t._v(" "),s("p",[t._v("只要内存空间允许，链表能插入的元素是无穷无尽的，并不需要像数组那样考虑扩容的问题。")]),t._v(" "),s("h3",{attrs:{id:"删除-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#删除-2"}},[t._v("#")]),t._v(" 删除")]),t._v(" "),s("p",[t._v("链表的删除操作同样分为三种情况：")]),t._v(" "),s("ul",[s("li",[t._v("尾部删除，是最简单的情况，把倒数第二个节点的next指向空即可：")]),t._v(" "),s("li",[t._v("头部删除，把链表的头节点设为原先头节点的next即可：")]),t._v(" "),s("li",[t._v("中间删除，只需把要删除节点的前置节点的next指针，直接指向要删除元素的后继节点即可")])]),t._v(" "),s("h2",{attrs:{id:"时间复杂度-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#时间复杂度-2"}},[t._v("#")]),t._v(" 时间复杂度")]),t._v(" "),s("p",[t._v("查找：时间复杂度是O(n)"),s("br"),t._v("\n如果不考虑更新，插入，删除之前查找元素的过程，只考虑纯粹的更新,插入,删除操作，时间复杂度都是O（1）。")]),t._v(" "),s("h2",{attrs:{id:"数组和链表的对比"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数组和链表的对比"}},[t._v("#")]),t._v(" 数组和链表的对比")]),t._v(" "),s("h4",{attrs:{id:"数组的优势"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数组的优势"}},[t._v("#")]),t._v(" 数组的优势")]),t._v(" "),s("p",[t._v("拥有非常高效的随机访问能力，只要给出下标，就可以用常量时间找到对应元素。")]),t._v(" "),s("h4",{attrs:{id:"数组的劣势"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数组的劣势"}},[t._v("#")]),t._v(" 数组的劣势")]),t._v(" "),s("p",[t._v("体现在插入和删除方面。由于数组元素连续紧密地存储在内存中，插入删除都导致大量元素被迫移动，影响效率。")]),t._v(" "),s("p",[s("strong",[t._v("数组所适合的是 读多写少 的场景")])]),t._v(" "),s("h4",{attrs:{id:"链表的优势"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#链表的优势"}},[t._v("#")]),t._v(" 链表的优势")]),t._v(" "),s("p",[t._v("在于灵活的插入和删除，如果需要在尾部频繁插入删除，用链表更合适一些。")]),t._v(" "),s("h4",{attrs:{id:"链表的劣势"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#链表的劣势"}},[t._v("#")]),t._v(" 链表的劣势")]),t._v(" "),s("p",[t._v("无法根据下标进行快速定位，只能从链表头节点开始，一个一个往下去找。")]),t._v(" "),s("p",[s("strong",[t._v("链表所适合的是 写多读少 的场景")])]),t._v(" "),s("h4",{attrs:{id:"性能比较"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#性能比较"}},[t._v("#")]),t._v(" 性能比较")]),t._v(" "),s("img",{staticStyle:{width:"50%"},attrs:{src:t.$withBase("/img/algorithm/9.jpg")}})])}),[],!1,null,null,null);a.default=v.exports}}]);