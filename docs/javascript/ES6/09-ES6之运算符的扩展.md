### 一. 链判断运算符
工作中，如果读取对象的某个属性，往往需要判断一下，属性的上层对象是否存在，常见的安全写法如下
```js
// 错误的写法
const  firstName = message.user.name || 'default';

// 正确的写法
const name = (message
  && message.user
  && message.user.name) || 'default';
```
ES2020 引入了“链判断运算符” `?.`简化上面的写法。

有三种写法:
- obj?.prop // 对象属性是否存在
- obj?.[expr] // 同上
- func?.(...args) // 函数或对象方法是否存在

判断规则：**左侧的对象是否为null或undefined。如果是的，就不再往下运算，而是返回undefined**
```js
// 写法一：判断对象属性是否存在
const name = message?.user?.name || 'default';

// 写法二：判断对象属性是否存在
const a = 'name';
const name = message?.user?.[a] || 'default';

/*
 *  写法三：函数或对象方法是否存在
 *  user.log如果有定义，就会调用该方法，
 *  否则user.log直接返回undefined，不再执行?.后面的部分。
 */
user.log?.()
```
下面是`?.`运算符常见形式，以及不使用该运算符时的等价形式。
```js
a?.b
// 等同于
a == null ? undefined : a.b

a?.[x]
// 等同于
a == null ? undefined : a[x]

a?.b()
// 等同于
a == null ? undefined : a.b()

a?.()
// 等同于
a == null ? undefined : a()
```
后两种形式:   
如果`a?.b()`里面的`a.b`有值，但不是函数，不可调用，那么`a?.b()`会报错  
`a?.()`也是如此，如果a不是null或undefined，但也不是函数，那么`a?.()`会报错

**注意点**
- 短路机制
`?.`运算符相当于一种短路机制，只要不满足条件，就不再往下执行
```js
a?.[++x]
// 等同于
a == null ? undefined : a[++x]
```
上面代码中，如果a是undefined或null，那么x不会进行递增运算
- 括号的影响
如果属性链有圆括号，链判断运算符对圆括号外部没有影响，只对圆括号内部有影响
```js
(a?.b).c
// 等价于
(a == null ? undefined : a.b).c
```
上面代码中，?.对圆括号外部没有影响，不管a对象是否存在，圆括号后面的.c总是会执行。

- 报错场合
以下写法是禁止的，会报错
```js
// 构造函数
new a?.()
new a?.b()

// 链判断运算符的右侧有模板字符串
a?.`{b}`
a?.b`{c}`

// 链判断运算符的左侧是 super
super?.()
super?.foo

// 链运算符用于赋值运算符左侧
a?.b = c
```
- 右侧不得为十进制数值

`foo?.3:0`被解析成`foo ? .3 : 0`

`?.`后面紧跟一个十进制数字，而会按照三元运算符进行处理，也就是说，那个小数点会归属于后面的十进制数字，形成一个小数。

### 二. Null 判断运算符
读取对象属性时，如果某个属性值是`null`或`undefined`，要为它们指定默认值，常见做法是使用`||`运算符指定默认值。
```js
const text = settings.title || 'Hello, world!';
const time = settings.time || 1000;
const showStyle= settings.showStyle || true;
```
开发者的原意是，只要属性的值为null或undefined，默认值就会生效，但是属性的值如果为空字符串或false或0，默认值也会生效。

 
ES2020 引入了一个新的Null判断运算符`??`。它的行为类似`||`，但是只有运算符左侧的值为`null`或`ndefined`时，才会返回右侧的值
```js
const text = settings.title ?? 'Hello, world!';
const time = settings.time ?? 1000;
const showStyle= settings.showStyle ?? true;
```
上面代码中，只有在左侧属性值为null或undefined时，默认值才会生效。

**这个运算符的作用，就是跟链判断运算符?.配合使用，为null或undefined的值设置默认值**
```js
const time = settings?.time ?? 1000;
```
上面代码中，如果settings是null或undefined，或者settings.time是null或undefined，就会返回默认值1000。

**注意: Object.assign()方法实行的是浅拷贝，而不是深拷贝**

#### 常见用途
1. 为对象添加属性
```js
class Point {
  constructor(x, y) {
    Object.assign(this, {x, y});
  }
}
```
2. 为对象添加方法
```js
Object.assign(SomeClass.prototype, {
  someMethod(arg1, arg2) {
    ···
  },
  anotherMethod() {
    ···
  }
});

// 等同于下面的写法
SomeClass.prototype.someMethod = function (arg1, arg2) {
  ···
};
SomeClass.prototype.anotherMethod = function () {
  ···
};
```
3. 克隆对象
```js
let newObj = Object.assign({}, origin)
```
4. 合并多个对象
```js
// 将多个对象合并到某个对象
const merge = (target, ...sources) => Object.assign(target, ...sources);

// 合并后返回一个新对象
const merge = (...sources) => Object.assign({}, ...sources);
```
5. 指定默认值
```js
const DEFAULTS = {
  age: 18,
  sex: '男'
};

function handle(options) {
  options = Object.assign({}, DEFAULTS, options);
  console.log(options);
  // ...
}
```

### 三. Object.getOwnPropertyDescriptors() 
ES5 的`Object.getOwnPropertyDescriptor()`方法会返回某个**对象属性**的描述对象;
ES6 的`Object.getOwnPropertyDescriptors()`方法，返回指定对象所有自身属性（非继承属性）的描述对象。
```js
const obj = {
  foo: 123,
  get bar() { return 'abc' }
};

Object.getOwnPropertyDescriptors(obj)
// { foo:
//    { value: 123,
//      writable: true,
//      enumerable: true,
//      configurable: true },
//   bar:
//    { get: [Function: get bar],
//      set: undefined,
//      enumerable: true,
//      configurable: true } }
```

### 四. Object.setPrototypeOf()，Object.getPrototypeOf()
`Object.setPrototypeOf()`用来设置一个对象的原型对象（prototype），返回参数对象本身

```js
// 格式
Object.setPrototypeOf(object, prototype)

// 示例
let proto = {};
let obj = { x: 10 };
Object.setPrototypeOf(obj, proto);

proto.y = 20;
proto.z = 40;

obj.x // 10
obj.y // 20
obj.z // 40

//如果第一个参数不是对象，会自动转为对象。但是由于返回的还是第一个参数，所以这个操作不会产生任何效果。
Object.setPrototypeOf(1, {}) === 1 // true
Object.setPrototypeOf('foo', {}) === 'foo' // true
Object.setPrototypeOf(true, {}) === true // true

//如果第一个参数是undefined或null，会报错。
Object.setPrototypeOf(undefined, {})
// TypeError: Object.setPrototypeOf called on null or undefined
```
`Object.setPrototypeOf`方法，用于读取一个对象的原型对象
```js
// 格式
Object.getPrototypeOf(obj);

// 示例
function Rectangle() {
  // ...
}

const rec = new Rectangle();

Object.getPrototypeOf(rec) === Rectangle.prototype // true

Object.setPrototypeOf(rec, Object.prototype);
Object.getPrototypeOf(rec) === Rectangle.prototype // false

// 如果参数不是对象，会被自动转为对象
// 等同于 Object.getPrototypeOf(Number(1))
Object.getPrototypeOf(1)
// Number {[[PrimitiveValue]]: 0}

Object.getPrototypeOf(1) === Number.prototype // true


//如果第一个参数是undefined或null，会报错。
Object.getPrototypeOf(null)
// TypeError: Cannot convert undefined or null to object
```

### 五. Object.keys()，Object.values()，Object.entries()，Object.fromEntries()
ES5 引入了`Object.keys`方法，返回一个给定对象的自身可枚举属性组成的数组
```js
var obj = { foo: 'bar', baz: 42 };
Object.keys(obj)
// ["foo", "baz"]
```
ES2017 引入了跟`Object.keys`配套的`Object.values`和`bject.entries`，作为遍历一个对象的补充手段，供for...of循环使用。

`Object.values()`方法返回一个给定对象自身的所有可枚举属性值的数组
```js
var obj = { foo: 'bar', baz: 42 };
Object.keys(obj)
// ["bar", "42"]
```
`Object.entries()`方法返回一个给定对象自身可枚举属性的键值对数组
```js
const obj = { foo: 'bar', baz: 42 };
Object.entries(obj)
// [ ["foo", "bar"], ["baz", 42] ]

// 实例
```
`Object.entries()`用途

```js
// 用途1：遍历对象的属性
let obj = { one: 1, two: 2 };
for (let [k, v] of Object.entries(obj)) {
  console.log(
    `${JSON.stringify(k)}: ${JSON.stringify(v)}`
  );
}
// "one": 1
// "two": 2

// 用途2：将对象转为真正的Map结构
const obj = { foo: 'bar', baz: 42 };
const map = new Map(Object.entries(obj));
map // Map { foo: "bar", baz: 42 }
```
`Object.fromEntries()`方法是`Object.entries()`的逆操作，用于将一个键值对数组转为对象。
```js
Object.fromEntries([
  ['foo', 'bar'],
  ['baz', 42]
])
// { foo: "bar", baz: 42 }
```


###六. Object.hasOwn() 
JavaScript 对象的属性分成两种：自身的属性和继承的属性。
ES5使用对象实例的`hasOwnProperty()`方法，可以判断某个属性是否为原生属性。  
ES2022 在Object对象上面新增了一个静态方法Object.hasOwn()，也可以判断是否为自身的属性。

```js
const foo = Object.create({ a: 123 });
foo.b = 456;

Object.hasOwn(foo, 'a') // false
Object.hasOwn(foo, 'b') // true
```
**区别**
Object.hasOwn()对于不继承Object.prototype的对象不会报错，而hasOwnProperty()会报错。
```js
const obj = Object.create(null);

obj.hasOwnProperty('foo') // 报错
Object.hasOwn(obj, 'foo') // false
```



***注：本文只记录了日常开发中常用的更新***


***参考资料***
[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object)
[阮一峰 ES6 入门教程](https://es6.ruanyifeng.com/)